Валентин
val.banas@gmail.com

* Lecture 1
** Атомарная переменная   или   список
Функция создания списков - list

Предикаты ATOM - проверка на атомарность переменной
          CONS - конструирование списка
** Сравнивание списков
eq        сравнение символов
eql       сравнивание чисел вне зависимости от типа    
          !!! Т при (eql 3 3.0)
equal     проверяет структурность
equalp    сравнение любых обьектов

null      проверка на ноль
** Bindings
Биндинги
    set    без автоматического квотирование
    setq   с кваотированием
    setf   наиболее общий вариант

вернуть забинденное значение
    symbol-value

(eval 'x)

** Functions
(defun <name>
    (<args>)
    form1
    form2
    ...
    formN
) -> result = formN

symbol-name
name-symbol

** Scopes
let     - локальные переменные
(let    ( (x 1)  (y 2) )
    form1
    form2
    ...
    formN
}

let*    - гарантирует порядок байндинга переменных

** УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ
(if () <then-form>
       <else-from>)


progn - последовательное выполнение форм (как {})

(COND
    (p1 f1)
    (p2 f2)
    ...
    (t fN))

(when () ...)
(unless () ...)

(loop ...)
(do ...)
(dolist ...)

** Home Work
*** Доделать прогу
*** Реализовать сортировку выбором на лиспе (2 способа) рекурсивный и нерекурсивный (+ направление)
*** В списке символов надо найти подсписок который содержит 2 пересекающихся полиндрома максимальной длинны (один символ не палиндром)
* Lection 2
(load "file.lsp")

** Functions as 1st class objects
** Closure
is a function definition + context
Замыкания. Контекст.
** Вызов функции
apply, funcall
apply - '(1 2 3 4 5) (или последний елемент - список)
funcall - 1 2 3 4 5
** rlwrap on gentoo
** maps
mapcar
mapc - возвращает сам список
mapcan - действие над последним елементом
!!! ДЕСТРУКТИВНЫЙ !!!
** folding
(reduce (lambda (a x) ()) '(1 2 3))
a - accumulator
x - element
** keys
initial parametrs
(func ... :keys)
(append
    :from-end t
    :initial-value '(i n i t))
** remove
(remove item lst &key from-end test)
(remove ...)
default remove test - eq
(remove-if ...)
(remove-if-not ...)
** complement
Создание обратного предиката
четное - нечетное
** Home Work
*** traverse-post (func tree fget-node fget-children)
как мапкар.
обход дерева, а не списка.
дерево.
представление девера.
fmake-node fmake-node fget-children

func
унарная функция
*** traverse-pre  (func tree fget-node fget-children fstop)
fstop - условие остановки
если t - остановка и удаление поддерева
